local CMDLOGGED = false
local CMDPARENT = "NONE"

local sDir = (parentShell and parentShell.dir()) or ""
local sPath = (parentShell and parentShell.path()) or ".:/rom/programs" or ".:/System/Programs"
local tAliases = (parentShell and parentShell.aliases()) or {}
local tCompletionInfo = (parentShell and parentShell.getCompletionInfo()) or {}
local tProgramStack = {}
local tEnv = {
    [ "shell" ] = shell,
    [ "multishell" ] = multishell,
    [ "System" ] = System
}

local rAliases = {
    [ "disconnect" ] = "/System/Programs/disconnect",
    [ "mon_connect" ] = "/System/Programs/mon_connect",
    [ "pwr" ] = "/System/Programs/pwr",
    [ "recovery" ] = "/System/Programs/recovery",
    [ "recovScript" ] = "/System/Programs/recovScript",
    [ "resize" ] = "/System/Programs/resize",
    [ "update" ] = "/System/Programs/update",
    [ "uptime" ] = "/System/Programs/uptime",
    [ "user" ] = "/System/Programs/user"
}

local function getTable(path)
    if fs.exists(path) then
        local file = io.open(path, "r")
        local lines = {}
        local i = 1
        local line = file:read("*l")
        while line ~= nil do
            lines[i] = line
            line = file:read("*l")
            i = i + 1
        end
        file:close()
        return lines
    end
    return {}
end

local function getSavedPass(getKey, username)
    if not username then
        username = CodeX_Username
    end
    local Passphrase_File = fs.open("/Users/"..username.."/.Passphrase.CodeX","r")
    local Passphrase_Key = Passphrase_File.readAll()
    Passphrase_File.close()
    local UnsavedPassword = StrUtils.SHA1(Key..""..Passphrase_Key)
    local Passphrase_Key = "Nope.avi"
    local Passphrase_File = "Nope.avi"
    return UnsavedPassword
end

--Check to see if the user is logged in.
if loggedIn == true then
    System.logInfo("CMD","CodeX user logged in from recovery.")
    --Yes, but from recovery.
    CMDLOGGED = true
    CMDPARENT = "Recovery"
else
    if CodeX_HasUserLogged == StrUtils.SHA1(CodeX_Username) then
        CMDLOGGED = true
        CMDPARENT = "CodeX"
    else
        System.logWarn("CMD","Failed to authorize the user. (CodeX_HasUserLogged failed to match.)")
    end
end


if CMDLOGGED == true then
    System.logInfo("CMD","CMDLOGGED is reported as true. CMDPARENT: "..CMDPARENT)
else
    System.logAlert("CMD","No user is logged in.")
    error("There is no user logged in.")
end


local function append(text, path)
    local file = assert(io.open(path, "a"))
    file:write(text.."\n")
    file:close()
end

Explorera_User_Prompt_Color = 512
Explorera_User_Background_Color = 32768
Explorera_User_Text_Color = 2048

local function config()
    if CodeX_Username then
        if fs.exists("/Users/"..CodeX_Username.."/.Configs/Explorera.conf") == true then
            local userfile =  getTable("/Users/"..CodeX_Username.."/.Configs/Explorera.conf")
            Explorera_User_Background_Color = System.transColor(tonumber(string.sub(userfile[1],string.find(userfile[1],":")+2)))
            Explorera_User_Prompt_Color = System.transColor(tonumber(string.sub(userfile[2],string.find(userfile[2],":")+2)))
            Explorera_User_Text_Color = System.transColor(tonumber(string.sub(userfile[3],string.find(userfile[3],":")+2)))
        end
    else
            local RitoOS_Config = getTable("/System/Configs/.Rito.conf")
            Explorera_User_Prompt_Color = System.transColor(tonumber(string.sub(RitoOS_Config[36],string.find(RitoOS_Config[36],":")+2)))
            Explorera_User_Background_Color = System.transColor(tonumber(string.sub(RitoOS_Config[37],string.find(RitoOS_Config[37],":")+2)))
            Explorera_User_Text_Color = System.transColor(tonumber(string.sub(RitoOS_Config[38],string.find(RitoOS_Config[38],":")+2)))
    end
end
-- Simple Write Script
local function fwrite(path, text)
        local file = assert(io.open(path, "w"))
        file:write(text)
        file:close()
end
-- End

if not term.isColor() then
    Explorera_User_Text_Color = colors.white
    Explorera_User_Background_Color = colors.black
    Explorera_User_Prompt_Color = colors.lightGray
end 

--Center Text
local function PrintCentered(sText)
msgLen = string.len(sText)
screenWidth,_ = term.getSize()
xCoords = tonumber(math.ceil((screenWidth / 2) - (msgLen / 2)))
_,termY = term.getCursorPos()
term.setCursorPos(xCoords,termY)
print(sText)
return xCoords
end

function downloadPaste(path,code)
    if http then
        local h=http.get('http://pastebin.com/raw.php?i='..code)
        if h then
            local f=fs.open(path,'w')
            f.write(h.readAll())
            f.close()
            h.close()
            return true
        else
            return false
        end
    else
            printError("/- Http not enabled! Please enable http -/")
            sleep(1)
            return false
    end
end
CMDVer = '0.5'

local function run( _sCommand, ... )
    local sPath = shell.resolveProgram( _sCommand )
    local Xcord, Ycord = term.getCursorPos()
    term.setCursorPos(1, 1)
    term.setTextColour(Explorera_User_Prompt_Color)
    term.clearLine()
    PrintCentered("Rito OS CMD V"..os.version())
    term.clearLine()
    PrintCentered("For help, type 'commands'")
    if ... ~= nil then
        term.clearLine()
        PrintCentered(_sCommand, ...)
        System.logInfo("CMD - User","[ Run command ] ".._sCommand .. " " .. ...)
    else
        term.clearLine()
        PrintCentered(_sCommand)
        System.logInfo("CMD - User","[ Run command ] ".._sCommand)
    end
    term.setCursorPos(Xcord, Ycord)
    term.setTextColour(Explorera_User_Text_Color)
    local sPath = shell.resolveProgram( _sCommand )
    if _sCommand == "restart" then
        print("Restarting the prompt...")
        dofile("/System/CMD.rxf")
    elseif _sCommand == "reboot" then
        os.reboot()
    elseif _sCommand == "shutdown" then
        os.shutdown()
    elseif _sCommand == "CrashMe!" then
        error("System.CMD.User.crash")
    elseif _sCommand == "exit" then
        error("Exit Command Ran")
    elseif _sCommand == "logout" then
        CodeX_logout()
    elseif _sCommand == "commands" then
        print("Rito commands:")
        print("reboot  - Reboots the computer")
        print("shutdown  - Shutdown the computer")
        print("update  - Update RitoOS")
        print("exit  - Exit and close explorera")
        print("recovery  - Reboot into recovery mode")
        print("logout - Logout of your account")
        print("user - Edit user account info")
        print("disconnect - Disconnect from a monitor")
        print("resize - Resize the UI on a monitor")
        print("uptime - Check RitoOS's uptime")
        print("mon_connect - Connect to a monitor")
    else
        if sPath ~= nil then
        tProgramStack[#tProgramStack + 1] = sPath
        if multishell then
            multishell.setTitle( multishell.getCurrent(), fs.getName( sPath ) )
        end
        local result = os.run( tEnv, sPath, ... )
        tProgramStack[#tProgramStack] = nil
        if multishell then
            if #tProgramStack > 0 then
                multishell.setTitle( multishell.getCurrent(), fs.getName( tProgramStack[#tProgramStack] ) )
            else
                multishell.setTitle( multishell.getCurrent(), "shell" )
            end
        end
        return result
        else
            printError("\"".._sCommand.."\" is neither a command nor a program.")
        end
    end
end -- End The Function

local function runLine( _sLine )
    local tWords = {}
    for match in string.gmatch( _sLine, "[^ \t]+" ) do
        table.insert( tWords, match )
    end

    local sCommand = tWords[1]
    if sCommand then
        return RunCommand( sCommand, unpack( tWords, 2 ) )
    end
    return false
end


local function tokenise( ... )
    local sLine = table.concat( { ... }, " " )
    local tWords = {}
    local bQuoted = false
    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do
        if bQuoted then
            table.insert( tWords, match )
        else
            for m in string.gmatch( match, "[^ \t]+" ) do
                table.insert( tWords, m )
            end
        end
        bQuoted = not bQuoted
    end
    return tWords
end

-- Install shell API
function shell.run( ... )
    local tWords = tokenise( ... )
    local sCommand = tWords[1]
    if sCommand then
        return run( sCommand, table.unpack( tWords, 2 ) )
    end
    return false
end

function shell.resolve( _sPath )
    local sStartChar = string.sub( _sPath, 1, 1 )
    if sStartChar == "/" or sStartChar == "\\" then
        return fs.combine( "", _sPath )
    else
        return fs.combine( sDir, _sPath )
    end
end

function shell.resolveProgram( _sCommand )
    -- RitoOS commands.
    if rAliases[ _sCommand ] ~= nil then
        _sCommand = rAliases[ _sCommand ]
    end

    -- Substitute aliases firsts
    if tAliases[ _sCommand ] ~= nil then
        _sCommand = tAliases[ _sCommand ]
    end



    -- If the path is a global path, use it directly
    local sStartChar = string.sub( _sCommand, 1, 1 )
    if sStartChar == "/" or sStartChar == "\\" then
        local sPath = fs.combine( "", _sCommand )
        if fs.exists( sPath ) and not fs.isDir( sPath ) then
            return sPath
        end
        return nil
    end
    
    -- Otherwise, look on the path variable
    for sPath in string.gmatch(sPath, "[^:]+") do
        sPath = fs.combine( shell.resolve( sPath ), _sCommand )
        if fs.exists( sPath ) and not fs.isDir( sPath ) then
            return sPath
        end
    end
    
    -- Not found
    return nil
end


local function RPrograms( _bIncludeHidden )
    local tItems = {}
    
    -- Add programs from the path
    for sPath in string.gmatch("/System/Programs/", "[^:]+") do
        sPath = shell.resolve( "/System/Programs/" )
        if fs.isDir( "/System/Programs/" ) then
            local tList = fs.list( "/System/Programs/" )
            for n=1,#tList do
                local sFile = tList[n]
                if not fs.isDir( fs.combine( "/System/Programs/", sFile ) ) and
                   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then
                    tItems[ sFile ] = true
                end
            end
        end
    end 

    -- Sort and return
    local tItemList = {}
    for sItem, b in pairs( tItems ) do
        table.insert( tItemList, sItem )
    end
    table.sort( tItemList )
    return tItemList
end

function Programs( _bIncludeHidden )
    local tItems = {}
    
    -- Add programs from the path
    for sPath in string.gmatch(sPath, "[^:]+") do
        sPath = shell.resolve( sPath )
        if fs.isDir( sPath ) then
            local tList = fs.list( sPath )
            for n=1,#tList do
                local sFile = tList[n]
                if not fs.isDir( fs.combine( sPath, sFile ) ) and
                   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then
                    tItems[ sFile ] = true
                end
            end
        end
    end 

    -- Sort and return
    local tItemList = {}
    for sItem, b in pairs( tItems ) do
        table.insert( tItemList, sItem )
    end
    table.sort( tItemList )
    return tItemList
end

local function completeProgram( sLine )
    if #sLine > 0 and string.sub( sLine, 1, 1 ) == "/" then
        -- Add programs from the root
        return fs.complete( sLine, "", true, false )

    else
        local tResults = {}
        local tSeen = {}

        -- Add RitoOS's programs
        local tPrograms = RPrograms()
        for n=1,#tPrograms do
            local sProgram = tPrograms[n]
            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then
                local sResult = string.sub( sProgram, #sLine + 1 )
                if not tSeen[ sResult ] then
                    table.insert( tResults, sResult )
                    tSeen[ sResult ] = true
                end
            end
        end

        -- Add aliases
        for sAlias, sCommand in pairs( tAliases ) do
            if #sAlias > #sLine and string.sub( sAlias, 1, #sLine ) == sLine then
                local sResult = string.sub( sAlias, #sLine + 1 )
                if not tSeen[ sResult ] then
                    table.insert( tResults, sResult )
                    tSeen[ sResult ] = true
                end
            end
        end

        -- Add programs from the path
        local tPrograms = Programs()
        for n=1,#tPrograms do
            local sProgram = tPrograms[n]
            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then
                local sResult = string.sub( sProgram, #sLine + 1 )
                if not tSeen[ sResult ] then
                    table.insert( tResults, sResult )
                    tSeen[ sResult ] = true
                end
            end
        end

        -- Sort and return
        table.sort( tResults )
        return tResults
    end
end

local function completeProgramArgument( sProgram, nArgument, sPart, tPreviousParts )
    local tInfo = tCompletionInfo[ sProgram ]
    if tInfo then
        return tInfo.fnComplete( shell, nArgument, sPart, tPreviousParts )
    end
    return nil
end

function shell.complete( sLine )
    if #sLine > 0 then
        local tWords = tokenise( sLine )
        local nIndex = #tWords
        if string.sub( sLine, #sLine, #sLine ) == " " then
            nIndex = nIndex + 1
        end
        if nIndex == 1 then
            local sBit = tWords[1] or ""
            local sPath = shell.resolveProgram( sBit )
            if tCompletionInfo[ sPath ] then
                return { " " }
            else
                local tResults = completeProgram( sBit )
                for n=1,#tResults do
                    local sResult = tResults[n]
                    local sPath = shell.resolveProgram( sBit .. sResult )
                    if tCompletionInfo[ sPath ] then
                        tResults[n] = sResult .. " "
                    end
                end
                return tResults
            end

        elseif nIndex > 1 then
            local sPath = shell.resolveProgram( tWords[1] )
            local sPart = tWords[nIndex] or ""
            local tPreviousParts = tWords
            tPreviousParts[nIndex] = nil
            return completeProgramArgument( sPath , nIndex - 1, sPart, tPreviousParts )

        end
    end
    return nil
end


local function command()
term.setBackgroundColor(Explorera_User_Background_Color)
term.setTextColour(Explorera_User_Prompt_Color)
term.clear()
term.setCursorPos(1,1)
PrintCentered("Rito OS CMD V"..os.version())
PrintCentered("For help, type 'commands'")
PrintCentered("You are in your home folder, do 'cd /'")
if CodeX_Username then
shell.setDir("/Users/"..CodeX_Username.."")
else
shell.setDir("/")
end
local tCommandHistory = {}
while not bExit do
    _on_promt_ = true
    term.setBackgroundColor(Explorera_User_Background_Color)
    term.setTextColour(Explorera_User_Prompt_Color)
    local Xcord, Ycord = term.getCursorPos()
    if Ycord == 1 then
    Ycord = 4
    term.setCursorPos(Xcord, Ycord)
    else
    term.setCursorPos(Xcord, Ycord)
    end
    write( "{-" .. shell.dir() .. "-} " )
    term.setTextColour(Explorera_User_Text_Color)
    local sLine = read( nil, tCommandHistory, shell.complete )
    table.insert( tCommandHistory, sLine )
    shell.run( sLine )
end
end --command
parallel.waitForAll(config,command)