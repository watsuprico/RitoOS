--[[

	Jello TaskMan


	Developed with love by @Watsuprico
]]

local args = {...}

local InternalSystem=args[1]
local CallerKey = args[2] -- The key of who requested this API (adjust API to this)

local TaskMan = {};

TaskMan.Threads = {}; -- Threads
TaskMan.ThreadsNameLookup = {}; -- Thread name -> thread id
TaskMan.GlobalEventQueue = {}; -- If events are globally queue, they live here



TaskMan.QueueEventsGlobally = true; -- Whether events queues are stored in the thread data or globally. This will speed things up significantly
TaskMan.QueueSizeLimit = 25; -- Queue will be pushed to threads once growing to this size. (Once QueueSizeLimit number of events have been received, we push all queued events to the threads)
TaskMan.QueueEvents = false; -- Disable, having this enabled adds overhead and slows it down. If disabled, two things above mean nothing.
TaskMan.ExitOnNoThreads = true; -- Exits the main loop when all threads have stopped.
TaskMan.NoThreadsHandler = nil; -- Function that is called when all threads close. This TaskMan object is passed as the first (and only) parameter. If you return true, the TaskMan exits
TaskMan.ExitOnEvent = false; -- Allows the TaskMan to stop upon receiving a special event (TaskMan.ExitEvent)
TaskMan.ExitEvent = "terminate"; -- If TaskMan.ExitOnEvent is true, this is the event that needs to be queued for the TaskMan to exit. When captured, TaskMan returns "furnit::TaskMan::exitevent",TaskMan.ExitEvent



--[[

	Pushes an event to a thread given the threadId. Note, this does not check if the thread is dead before hand, please check that.

	Advance, do not call manually unless you're implementing your own looper.

	@tparam number Thread id to push the event to
	@tparam table Packed event (table, we use table.unpack to pass the event through)
]]
TaskMan.PushEventToThreadId = function(thread, event)
	local thread = TaskMan.Threads[threadId];
	if (thread.Filter == nil or thread.Filter == event[1] or thread.Filter == "terminate") then
		local okay, coroutineYieldedData = coroutine.resume(thread.Coroutine, table.unpack(event, 1, event.n));
		if not okay then
			thread.status = "dead";
			if (type(thread.EventHandler) == "function") then
				thread.EventHandler("furnit::thread::error", thread, table.unpack(coroutineYieldedData));
			end
		else
			thread.Filter = coroutineYieldedData;
		end
	end
end

--[[

	Push and events in the event queue to the thread's coroutine.

	Advance, do not call manually unless you're implementing your own looper.

	@tparam[opt=nil] table The event (packed) to be passed in (only works if TaskMan.QueueEvents is false)
]]
TaskMan.PushQueuedEventsToThreads = function(event)
	for tId, thread in pairs(TaskMan.Threads) do
		if thread.Status ~= "dead" then -- Found to be marginally quicker than calling coroutine.status() .... ok then
			if TaskMan.QueueEvents and event == nil then
				if TaskMan.QueueEventsGlobally then
					for i = 1, #TaskMan.GlobalEventQueue do
						TaskMan.PushEventToThreadId(tId, TaskMan.GlobalEventQueue[i]);
					end
				else
					for i = 1, #thread.EventQueue do
						TaskMan.PushEventToThreadId(tId, thread.EventQueue[i]);
					end
					thread.EventQueue = {};
				end
			elseif event ~= nil then
				TaskMan.PushEventToThreadId(tId, event);
			end
		else
			if (type(thread.EventHandler) == "function") then
				thread.ErrorHandler("furnit::thread::dead", thread, table.unpack(coroutineYieldedData));
			end
			TaskMan.Threads[tId] = nil;
		end

		thread.Status = coroutine.status(thread.Coroutine);
	end

	-- Clear queue
	if TaskMan.QueueEventsGlobally then
		TaskMan.GlobalEventQueue = {}
	end
end


--[[

	Adds an event to the queue to be pushed to threads later by the TaskMan.

	@tparam string|number Event, similar to what you would pass in os.queueEvent()

]]
TaskMan.QueueEvent = function(...)
	local event = {...}
	if TaskMan.QueueEvents then
		if TaskMan.QueueEventsGlobally then
			TaskMan.GlobalEventQueue[#TaskMan.GlobalEventQueue+1] = event;
		else
			for tId, thread in pairs(TaskMan.Threads) do
				if (thread.Status == "suspended") then
					thread.EventQueue[#thread.EventQueue+1] = event;
				end
			end
		end
	else
		TaskMan.PushQueuedEventsToThreads(event);
	end
end

--[[
	Runs the event handler, captures coroutine.yield() and pushes those events to all threads in this.Threads

	To kick things off, we queue "furnit::TaskMan::run". This allows the coroutine.yield() to grab something and start each thread already added.
	This does not return, unless TaskMan.ExitOnEvent is true and TaskMan.ExitEvent and captured OR TaskMan.ExitOnNoThreads is true and all threads die

	@treturn string Exit reason
]]
TaskMan.Run = function()
	TaskMan.CurrentQueueSize=TaskMan.QueueSizeLimit;
	local event;
	os.queueEvent("furnit::TaskMan::run");
	while true do
		event = {coroutine.yield()};
		if (event[1] == TaskMan.ExitEvent and TaskMan.ExitOnEvent == true) then
			return "furnit::TaskMan::exitevent", event[1];
		else
			TaskMan.QueueEvent(table.unpack(event));
			if TaskMan.QueueEvents and TaskMan.CurrentQueueSize >= TaskMan.QueueSizeLimit then
				TaskMan.PushQueuedEventsToThreads();
				TaskMan.CurrentQueueSize = 0;
			end

			if #TaskMan.Threads <= 0 then
				if type(TaskMan.NoThreadsHandler) == "function" then
					if TaskMan.NoThreadsHandler(TaskMan) == true then
						return "furnit::TaskMan::nothreads";
					end
				elseif TaskMan.ExitOnNoThreads then
					return "furnit::TaskMan::nothreads";
				end
			end
		end

		TaskMan.CurrentQueueSize = TaskMan.CurrentQueueSize + 1;
	end
end

--[[

	Creates a new furnit::TaskMan::thread object

	@tparam thread Coroutine to run in this thread
	@tparam[opt=nil] string Name of the new thread. Used for lookup purposes, strictly cosmetic and for administrative purposes. If empty, we use the Lua hash value of the coroutine (coroutine#1234).
	@tparam[opt=nil] function Event handler function that receives error codes or other thread related events (furnit::thread::dead, furnit::thread::killed, furnit::thread::error).
	@treturn furnit::TaskMan::thread Thread that can then be added via RunThread()
]]
TaskMan.NewThread = function(coroutineObj, name, eventHandler)
	if type(coroutineObj) ~= "thread" then
		error("Parameter #1, coroutineObj, expected type 'thread' got '" .. type(coroutineObj) .. "'");
	end
	if name == nil then
		name = tostring(coroutineObj)
	end
	if type(name) ~= "string" then
		error("Parameter #2, name, expected type 'string' got '" .. type(name) .. "'");
	end
	if type(eventHandler) ~= "function" and eventHandler ~= nil then
		error("Parameter #3, eventHandler, expected type 'function' got '" .. type(eventHandler) .. "'");
	end

	return {
		["Name"] = name,
		["Status"] = "suspended", -- coroutine.status(-) cache (slightly quicker)
		["Coroutine"] = coroutineObj,
		["EventQueue"] = {}, -- Events that will be pushed to the coroutine next resume
		["Filter"] = nil, -- Data passed by the coroutine when it yielded
		["EventHandler"] = eventHandler, -- Event handler (thread_died, thread_killed, thread_error)
	};
end

--[[
	Adds a furnit::TaskMan::thread to the this.Threads table, it'll be picked up in the next cycle.

	@tparam furnit::TaskMan::thread Thread to add to the list of Thread running
	@treturn number Thread id
]]
TaskMan.RunThread = function(thread)
	if (type(thread.Coroutine) ~= "thread") then
		error("thread.Coroutine expected type 'thread' got type " .. type(thread.Coroutine));
	end
	if (type(thread.EventHandler) ~= "function" and thread.EventHandler ~= nil) then
		error("thread.EventHandler expected type 'thread' got type " .. type(thread.Coroutine));
	end
	if (type(thread.EventQueue) ~= "table" or (TaskMan.QueueEvents == false or TaskMan.QueueEventsGlobally)) then
		-- If EventQueue not a table, set as a empty table
		-- If this will not be used, set as empty
		thread.EventQueue = {};
	end

	thread.Status = coroutine.status(thread.Coroutine);

	local threadIndex;
	for i = 1, #TaskMan.Threads+1 do
		if TaskMan.Threads[i] == nil then
			threadIndex = i;
			break;
		end
	end
	TaskMan.Threads[threadIndex] = thread;
	return threadIndex;
end

--[[

	Creates a new coroutine, new furnit::TaskMan::thread, and calls TaskMan.RunThread() to run said new thread.
	You pass the function you wish to run in this thread as the first parameter, any additional parameters are passed to the function you passed in.

	@tparam function Function that will run in the thread
	@tparam any Arguments to pass to your function
	@treturn[1] furnit::TaskMan::thread

]]
TaskMan.RunFunction = function(func, ...)
	local paramters = {...};
	if type(func) ~= "function" then
		error("Parameter #1, func, expected type 'function' got '" .. type(eventHandler) .. "'");
	end
	
	local thread = TaskMan.NewThread( coroutine.create(function() func(table.unpack(paramters)) end) );
	TaskMan.RunThread(thread);

	return thread;
end


TaskMan.NewSession = function(userId, userPackage) -- a session is a user login session
	-- Creates the terminals and whatnot
	if type(userId) ~= "string" then
		error("UserId (#1) expected string, got " .. type(userId))
	end
	if InternalSystem.Sessions[userId] ~= nil then
		error("Session already exists")
	end

	local session = {}

	Log.Info("Creating term objects for " .. userId)
	session.Terms["LockScreen"] = window.create(Internal.Terms["User"], 1,1, Internal.Terms.Width,Internal.Terms.Height, true)
	session.Terms["UserSpace"] = window.create(Internal.Terms["User"], 1,1, Internal.Terms.Width,Internal.Terms.Height, false)
	session.Terms["SecureUserSpace"] = window.create(Internal.Terms["User"], 1,1, Internal.Terms.Width,Internal.Terms.Height, false)
	session.Terms["OS2U"] = window.create(Internal.Terms["SecureOS"] or Internal.Terms["OS"], 1,1, Internal.Terms.Width,Internal.Terms.Height, false)

	-- Create ...???
	session.username = userPackage.username;
	session.userID = userPackage.userID;
	session.IHP = userPackage.IHP;
	session.CUD = userPackage.CUD;


	-- Done
	Internal.Sessions[userID] = session
end

-- NewProcess(Table ProcessData[, String UserID])
TaskMan.NewProcess = function(processData, userId)
	local userID = userId or hostID

	-- Do some Holtin perm check here

	-- Create the process
	local Process = {}
	local ProcessID = Internal.TM.LastPID

	-- Check to see if the ProcessData is 'valid'
	local check = function(name, t)
		if type(ProcessData[name]) ~= t then
			error("ProcessData is invalid. "..name.." expected "..t.." but got "..type(ProcessData[name]))
		end
	end

	check("name","string")
	check("term","table")
	ProcessData.environment = ProcessData.environment or {}
	check("environment","table")
	-- there should be a bunch of other stuff here..
end

-- .NewThread(int PID[, String UserID])
TaskMan.NewThread = function(pid, userId)
end
-- .Run(String PathToExecutable[, boolean RitoOSAppPackage, String UserID])
TaskMan.Run = function()
end

-- .ListSessions()
TaskMan.ListSessions = function()
end
-- .ListProcesses([String UserID])
TaskMan.ListProcesses = function()
end
-- .ListThreads(int PID[, String UserID])
TaskMan.ListThreads = function()
end

-- .RemoveSession(String UserID)
TaskMan.RemoveSession = function()
end
-- .RemoveProcess(int PID[, String UserID])
TaskMan.RemoveProcess = function()
end
-- .RemoveThread(int PID[, String UserID])
TaskMan.RemoveThread = function()
end


-- .GetProcessData(int PID[, String UserID])
TaskMan.GetProcessData = function()
end

-- .EmptyProcessData
TaskMan.EmptyProcessData = function()
	-- ???
end


-- .TaskBroker()
TaskMan.TaskBroker = function()
	TaskMan.CurrentQueueSize=TaskMan.QueueSizeLimit;
	local event;
	os.queueEvent("furnit::TaskMan::run");
	while true do
		event = {coroutine.yield()};
		if (event[1] == TaskMan.ExitEvent and TaskMan.ExitOnEvent == true) then
			return "furnit::TaskMan::exitevent", event[1];
		else
			TaskMan.QueueEvent(table.unpack(event));
			if TaskMan.QueueEvents and TaskMan.CurrentQueueSize >= TaskMan.QueueSizeLimit then
				TaskMan.PushQueuedEventsToThreads();
				TaskMan.CurrentQueueSize = 0;
			end

			if #TaskMan.Threads <= 0 then
				if type(TaskMan.NoThreadsHandler) == "function" then
					if TaskMan.NoThreadsHandler(TaskMan) == true then
						return "furnit::TaskMan::nothreads";
					end
				elseif TaskMan.ExitOnNoThreads then
					return "furnit::TaskMan::nothreads";
				end
			end
		end

		TaskMan.CurrentQueueSize = TaskMan.CurrentQueueSize + 1;
	end
end



return TaskMan;